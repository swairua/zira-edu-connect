import { useState, useMemo } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Slider } from '@/components/ui/slider';
import { Badge } from '@/components/ui/badge';
import { Wand2, AlertCircle, Sparkles, Check, AlertTriangle } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { Question, ExamPaperSection } from '@/types/question-bank';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

interface AutoGenerateDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  sections: ExamPaperSection[];
  availableQuestions: Question[];
  subjectId: string;
  institutionId?: string;
  staffId?: string;
  onGenerate: (sectionQuestions: { sectionIndex: number; questionIds: string[] }[]) => void;
}

interface SectionConfig {
  targetMarks: number;
  easyPercent: number;
  mediumPercent: number;
  hardPercent: number;
}

interface GapAnalysis {
  totalTargetMarks: number;
  availableMarks: number;
  gap: number;
  canMeetTarget: boolean;
  byDifficulty: {
    easy: { target: number; available: number; gap: number };
    medium: { target: number; available: number; gap: number };
    hard: { target: number; available: number; gap: number };
  };
}

export function AutoGenerateDialog({
  open,
  onOpenChange,
  sections,
  availableQuestions,
  subjectId,
  institutionId,
  staffId,
  onGenerate,
}: AutoGenerateDialogProps) {
  const [sectionConfigs, setSectionConfigs] = useState<SectionConfig[]>(
    sections.map((s) => ({
      targetMarks: s.marks,
      easyPercent: 50,
      mediumPercent: 30,
      hardPercent: 20,
    }))
  );
  const [isGenerating, setIsGenerating] = useState(false);
  const [isGeneratingAI, setIsGeneratingAI] = useState(false);
  const [showGapOptions, setShowGapOptions] = useState(false);

  // Filter questions by subject
  const filteredQuestions = useMemo(() => 
    availableQuestions.filter((q) => q.subject_id === subjectId && q.is_active),
    [availableQuestions, subjectId]
  );

  // Calculate available marks by difficulty
  const availableMarksByDifficulty = useMemo(() => {
    const easy = filteredQuestions
      .filter((q) => q.difficulty === 'easy')
      .reduce((sum, q) => sum + q.marks, 0);
    const medium = filteredQuestions
      .filter((q) => q.difficulty === 'medium')
      .reduce((sum, q) => sum + q.marks, 0);
    const hard = filteredQuestions
      .filter((q) => q.difficulty === 'hard')
      .reduce((sum, q) => sum + q.marks, 0);
    return { easy, medium, hard, total: easy + medium + hard };
  }, [filteredQuestions]);

  const getQuestionStats = () => {
    const easy = filteredQuestions.filter((q) => q.difficulty === 'easy');
    const medium = filteredQuestions.filter((q) => q.difficulty === 'medium');
    const hard = filteredQuestions.filter((q) => q.difficulty === 'hard');
    return { 
      easy: easy.length, 
      medium: medium.length, 
      hard: hard.length, 
      total: filteredQuestions.length,
      easyMarks: easy.reduce((sum, q) => sum + q.marks, 0),
      mediumMarks: medium.reduce((sum, q) => sum + q.marks, 0),
      hardMarks: hard.reduce((sum, q) => sum + q.marks, 0),
    };
  };

  const stats = getQuestionStats();

  // Gap Analysis
  const gapAnalysis: GapAnalysis = useMemo(() => {
    const totalTargetMarks = sectionConfigs.reduce((sum, c) => sum + c.targetMarks, 0);
    
    let totalEasyTarget = 0, totalMediumTarget = 0, totalHardTarget = 0;
    sectionConfigs.forEach(config => {
      totalEasyTarget += Math.round((config.easyPercent / 100) * config.targetMarks);
      totalMediumTarget += Math.round((config.mediumPercent / 100) * config.targetMarks);
      totalHardTarget += Math.round((config.hardPercent / 100) * config.targetMarks);
    });

    return {
      totalTargetMarks,
      availableMarks: availableMarksByDifficulty.total,
      gap: Math.max(0, totalTargetMarks - availableMarksByDifficulty.total),
      canMeetTarget: availableMarksByDifficulty.total >= totalTargetMarks,
      byDifficulty: {
        easy: {
          target: totalEasyTarget,
          available: availableMarksByDifficulty.easy,
          gap: Math.max(0, totalEasyTarget - availableMarksByDifficulty.easy),
        },
        medium: {
          target: totalMediumTarget,
          available: availableMarksByDifficulty.medium,
          gap: Math.max(0, totalMediumTarget - availableMarksByDifficulty.medium),
        },
        hard: {
          target: totalHardTarget,
          available: availableMarksByDifficulty.hard,
          gap: Math.max(0, totalHardTarget - availableMarksByDifficulty.hard),
        },
      },
    };
  }, [sectionConfigs, availableMarksByDifficulty]);

  const updateSectionConfig = (index: number, updates: Partial<SectionConfig>) => {
    setSectionConfigs((prev) => {
      const newConfigs = [...prev];
      newConfigs[index] = { ...newConfigs[index], ...updates };
      return newConfigs;
    });
  };

  const adjustDistribution = (index: number, key: 'easyPercent' | 'mediumPercent' | 'hardPercent', value: number) => {
    const config = sectionConfigs[index];
    const others = ['easyPercent', 'mediumPercent', 'hardPercent'].filter(k => k !== key) as ('easyPercent' | 'mediumPercent' | 'hardPercent')[];
    
    const remaining = 100 - value;
    const currentOtherTotal = config[others[0]] + config[others[1]];
    
    if (currentOtherTotal === 0) {
      updateSectionConfig(index, {
        [key]: value,
        [others[0]]: remaining / 2,
        [others[1]]: remaining / 2,
      });
    } else {
      const ratio0 = config[others[0]] / currentOtherTotal;
      const ratio1 = config[others[1]] / currentOtherTotal;
      updateSectionConfig(index, {
        [key]: value,
        [others[0]]: Math.round(remaining * ratio0),
        [others[1]]: Math.round(remaining * ratio1),
      });
    }
  };

  const handleGenerate = () => {
    // Check if we can meet target
    if (!gapAnalysis.canMeetTarget) {
      setShowGapOptions(true);
      return;
    }
    
    executeGeneration();
  };

  const executeGeneration = () => {
    setIsGenerating(true);

    const result: { sectionIndex: number; questionIds: string[] }[] = [];
    const usedQuestionIds = new Set<string>();

    sections.forEach((section, sectionIndex) => {
      const config = sectionConfigs[sectionIndex];
      const targetMarks = config.targetMarks;
      
      const easyMarks = Math.round((config.easyPercent / 100) * targetMarks);
      const mediumMarks = Math.round((config.mediumPercent / 100) * targetMarks);
      const hardMarks = targetMarks - easyMarks - mediumMarks;

      const selectedIds: string[] = [];

      const selectByDifficulty = (difficulty: 'easy' | 'medium' | 'hard', targetMarks: number) => {
        let currentMarks = 0;
        const candidates = filteredQuestions
          .filter((q) => q.difficulty === difficulty && !usedQuestionIds.has(q.id))
          .sort(() => Math.random() - 0.5);

        for (const q of candidates) {
          if (currentMarks + q.marks <= targetMarks) {
            selectedIds.push(q.id);
            usedQuestionIds.add(q.id);
            currentMarks += q.marks;
          }
        }
      };

      selectByDifficulty('easy', easyMarks);
      selectByDifficulty('medium', mediumMarks);
      selectByDifficulty('hard', hardMarks);

      result.push({ sectionIndex, questionIds: selectedIds });
    });

    onGenerate(result);
    setIsGenerating(false);
    onOpenChange(false);
  };

  const handleGenerateWithAI = async () => {
    if (!institutionId || !staffId) {
      toast.error('Missing institution or staff information');
      return;
    }

    setIsGeneratingAI(true);

    try {
      // Calculate what we need to generate
      const gaps = gapAnalysis.byDifficulty;
      const questionsToGenerate: { difficulty: string; count: number }[] = [];

      if (gaps.easy.gap > 0) {
        questionsToGenerate.push({ difficulty: 'easy', count: Math.ceil(gaps.easy.gap / 2) });
      }
      if (gaps.medium.gap > 0) {
        questionsToGenerate.push({ difficulty: 'medium', count: Math.ceil(gaps.medium.gap / 3) });
      }
      if (gaps.hard.gap > 0) {
        questionsToGenerate.push({ difficulty: 'hard', count: Math.ceil(gaps.hard.gap / 4) });
      }

      // Get subject info
      const { data: subject } = await supabase
        .from('subjects')
        .select('name, code')
        .eq('id', subjectId)
        .maybeSingle();

      if (!subject) {
        throw new Error('Subject not found');
      }

      // Generate questions for each difficulty that has a gap
      for (const { difficulty, count } of questionsToGenerate) {
        const { data, error } = await supabase.functions.invoke('generate-questions', {
          body: {
            subject_code: subject.code || subject.name,
            grade_level: 'Grade 6', // Default, could be parameterized
            question_type: 'multiple_choice',
            difficulty,
            count,
            topic: `${subject.name} Assessment`,
          },
        });

        if (error) {
          console.error('AI generation error:', error);
          throw error;
        }

        if (data?.questions?.length) {
          // Save generated questions to the bank
          for (const q of data.questions) {
            await supabase.from('question_bank').insert([{
              subject_id: subjectId,
              institution_id: institutionId,
              created_by: staffId,
              question_text: q.question_text,
              question_type: q.question_type,
              difficulty: q.difficulty,
              marks: q.marks,
              options: q.options,
              correct_answer: q.correct_answer,
              cognitive_level: q.cognitive_level || 'understanding',
              is_active: true,
              tags: ['ai-generated'],
              topic: `${subject.name} Assessment`,
            }]);
          }
        }
      }

      toast.success('AI generated additional questions! Re-generating paper...');
      
      // Refresh and regenerate
      setTimeout(() => {
        executeGeneration();
        setIsGeneratingAI(false);
        setShowGapOptions(false);
      }, 1000);

    } catch (error) {
      console.error('Error generating AI questions:', error);
      toast.error('Failed to generate questions with AI');
      setIsGeneratingAI(false);
    }
  };

  const totalTargetMarks = sectionConfigs.reduce((sum, c) => sum + c.targetMarks, 0);
  const fillPercentage = Math.min(100, (availableMarksByDifficulty.total / totalTargetMarks) * 100);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl max-h-[85vh] flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Wand2 className="h-5 w-5 text-primary" />
            Auto-Generate Questions
          </DialogTitle>
          <DialogDescription>
            Configure difficulty distribution and let the system select questions from your bank.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto space-y-4 py-4">
          {/* Question Bank Stats */}
          <Alert>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              <div className="flex justify-between items-center">
                <span>Available questions for this subject: <strong>{stats.total}</strong></span>
                <span className="text-sm">Total marks: <strong>{availableMarksByDifficulty.total}</strong></span>
              </div>
              <div className="flex gap-2 mt-2">
                <Badge variant="outline" className="bg-green-50 text-green-700 dark:bg-green-950 dark:text-green-300">
                  Easy: {stats.easy} ({stats.easyMarks}m)
                </Badge>
                <Badge variant="outline" className="bg-yellow-50 text-yellow-700 dark:bg-yellow-950 dark:text-yellow-300">
                  Medium: {stats.medium} ({stats.mediumMarks}m)
                </Badge>
                <Badge variant="outline" className="bg-red-50 text-red-700 dark:bg-red-950 dark:text-red-300">
                  Hard: {stats.hard} ({stats.hardMarks}m)
                </Badge>
              </div>
            </AlertDescription>
          </Alert>

          {/* Gap Analysis Display */}
          <div className="p-4 rounded-lg border bg-muted/30">
            <div className="flex justify-between items-center mb-2">
              <span className="text-sm font-medium">Target Coverage</span>
              <span className="text-sm">
                {availableMarksByDifficulty.total} / {totalTargetMarks} marks
              </span>
            </div>
            <Progress value={fillPercentage} className="h-2" />
            <div className="flex justify-between items-center mt-2 text-xs text-muted-foreground">
              <span>
                {gapAnalysis.canMeetTarget ? (
                  <span className="flex items-center gap-1 text-green-600">
                    <Check className="h-3 w-3" /> Can meet target
                  </span>
                ) : (
                  <span className="flex items-center gap-1 text-amber-600">
                    <AlertTriangle className="h-3 w-3" /> Gap: {gapAnalysis.gap} marks
                  </span>
                )}
              </span>
              <span>{Math.round(fillPercentage)}% available</span>
            </div>
          </div>

          {stats.total === 0 ? (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                No questions available in the question bank for this subject. Please add questions first or use AI to generate them.
              </AlertDescription>
            </Alert>
          ) : showGapOptions ? (
            // Gap Options View
            <div className="space-y-4">
              <Alert>
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription>
                  <strong>Insufficient questions in your bank.</strong>
                  <p className="mt-1">
                    You need {totalTargetMarks} marks but only have {availableMarksByDifficulty.total} marks available.
                  </p>
                  <div className="mt-3 space-y-1 text-sm">
                    {gapAnalysis.byDifficulty.easy.gap > 0 && (
                      <p>• Easy: need {gapAnalysis.byDifficulty.easy.gap} more marks</p>
                    )}
                    {gapAnalysis.byDifficulty.medium.gap > 0 && (
                      <p>• Medium: need {gapAnalysis.byDifficulty.medium.gap} more marks</p>
                    )}
                    {gapAnalysis.byDifficulty.hard.gap > 0 && (
                      <p>• Hard: need {gapAnalysis.byDifficulty.hard.gap} more marks</p>
                    )}
                  </div>
                </AlertDescription>
              </Alert>

              <div className="grid gap-3">
                <Button
                  onClick={handleGenerateWithAI}
                  disabled={isGeneratingAI}
                  className="w-full"
                >
                  <Sparkles className="h-4 w-4 mr-2" />
                  {isGeneratingAI ? 'Generating with AI...' : `Generate ${gapAnalysis.gap} marks with AI`}
                </Button>
                <Button
                  variant="outline"
                  onClick={executeGeneration}
                  disabled={isGenerating}
                  className="w-full"
                >
                  Proceed with available ({availableMarksByDifficulty.total}/{totalTargetMarks} marks)
                </Button>
                <Button
                  variant="ghost"
                  onClick={() => setShowGapOptions(false)}
                  className="w-full"
                >
                  Go Back & Adjust
                </Button>
              </div>
            </div>
          ) : (
            // Normal Configuration View
            <div className="space-y-6">
              {sections.map((section, index) => (
                <div key={index} className="border rounded-lg p-4 space-y-4">
                  <div className="flex justify-between items-center">
                    <h4 className="font-medium">{section.name}</h4>
                    <Badge variant="secondary">{section.marks} marks</Badge>
                  </div>

                  <div>
                    <Label className="text-sm">Target Marks for this Section</Label>
                    <Input
                      type="number"
                      value={sectionConfigs[index]?.targetMarks || section.marks}
                      onChange={(e) => updateSectionConfig(index, { targetMarks: parseInt(e.target.value) || 0 })}
                      className="mt-1 w-32"
                    />
                  </div>

                  <div className="space-y-3">
                    <Label className="text-sm">Difficulty Distribution</Label>
                    
                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-green-600 dark:text-green-400">Easy</span>
                        <span className="text-sm font-medium">{sectionConfigs[index]?.easyPercent || 50}%</span>
                      </div>
                      <Slider
                        value={[sectionConfigs[index]?.easyPercent || 50]}
                        onValueChange={([v]) => adjustDistribution(index, 'easyPercent', v)}
                        max={100}
                        step={5}
                        className="[&_[role=slider]]:bg-green-500"
                      />
                    </div>

                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-yellow-600 dark:text-yellow-400">Medium</span>
                        <span className="text-sm font-medium">{sectionConfigs[index]?.mediumPercent || 30}%</span>
                      </div>
                      <Slider
                        value={[sectionConfigs[index]?.mediumPercent || 30]}
                        onValueChange={([v]) => adjustDistribution(index, 'mediumPercent', v)}
                        max={100}
                        step={5}
                        className="[&_[role=slider]]:bg-yellow-500"
                      />
                    </div>

                    <div className="space-y-2">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-red-600 dark:text-red-400">Hard</span>
                        <span className="text-sm font-medium">{sectionConfigs[index]?.hardPercent || 20}%</span>
                      </div>
                      <Slider
                        value={[sectionConfigs[index]?.hardPercent || 20]}
                        onValueChange={([v]) => adjustDistribution(index, 'hardPercent', v)}
                        max={100}
                        step={5}
                        className="[&_[role=slider]]:bg-red-500"
                      />
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {!showGapOptions && (
          <DialogFooter>
            <Button variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button
              onClick={handleGenerate}
              disabled={stats.total === 0 || isGenerating}
            >
              <Wand2 className="h-4 w-4 mr-2" />
              {isGenerating ? 'Generating...' : 'Generate Questions'}
            </Button>
          </DialogFooter>
        )}
      </DialogContent>
    </Dialog>
  );
}
