import { useState, useCallback, useRef } from 'react';
import Papa from 'papaparse';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Upload, AlertCircle, CheckCircle2, X, Download, Users, UserPlus, Sparkles } from 'lucide-react';
import { useBulkCreateStudents } from '@/hooks/useStudents';
import { supabase } from '@/integrations/supabase/client';
import { useClasses } from '@/hooks/useClasses';
import { useAdmissionNumberPreview } from '@/hooks/useAdmissionNumber';
import { ImportColumnReference } from '@/components/imports/ImportColumnReference';
import { STUDENT_IMPORT_DEFINITION, generateTemplateCSV, formatValidationError } from '@/config/importColumnDefinitions';

interface ParsedStudent {
  admission_number: string;
  first_name: string;
  middle_name?: string;
  last_name: string;
  gender?: string;
  date_of_birth?: string;
  nationality?: string;
  admission_date?: string;
  // Enhanced fields for class and parent linking
  class_name?: string;
  stream?: string;
  boarding_status?: string;
  parent_phone?: string;
  parent_name?: string;
  parent_email?: string;
  parent_relationship?: string;
  // Flag for auto-generation
  _needs_admission_number?: boolean;
}

interface ValidationError {
  row: number;
  field: string;
  message: string;
}

interface BulkStudentImportDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  institutionId: string;
  existingAdmissionNumbers: string[];
}

const REQUIRED_COLUMNS = ['first_name', 'last_name'];
const OPTIONAL_COLUMNS = [
  'admission_number', 'middle_name', 'gender', 'date_of_birth', 'nationality', 'admission_date',
  'class_name', 'stream', 'boarding_status',
  'parent_phone', 'parent_name', 'parent_email', 'parent_relationship'
];
const ALL_COLUMNS = ['admission_number', ...REQUIRED_COLUMNS.filter(c => c !== 'admission_number'), ...OPTIONAL_COLUMNS.filter(c => c !== 'admission_number')];

export function BulkStudentImportDialog({
  open,
  onOpenChange,
  institutionId,
  existingAdmissionNumbers,
}: BulkStudentImportDialogProps) {
  const [step, setStep] = useState<'upload' | 'preview' | 'importing' | 'complete'>('upload');
  const [parsedData, setParsedData] = useState<ParsedStudent[]>([]);
  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);
  const [importProgress, setImportProgress] = useState(0);
  const [autoGenerateForEmpty, setAutoGenerateForEmpty] = useState(true);
  const [importResults, setImportResults] = useState<{ 
    students: number; 
    parents: number;
    classAssignments: number;
    autoGenerated: number;
    failed: number;
  }>({ students: 0, parents: 0, classAssignments: 0, autoGenerated: 0, failed: 0 });
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const bulkCreate = useBulkCreateStudents();
  const { data: classes } = useClasses(institutionId);
  const { data: admissionPreview } = useAdmissionNumberPreview();

  // Build class lookup map
  const classLookup = new Map<string, string>();
  classes?.forEach(c => {
    // Map by full name (e.g., "Grade 1 A")
    classLookup.set(c.name.toLowerCase(), c.id);
    // Also map by level + stream combination
    if (c.stream) {
      classLookup.set(`${c.level} ${c.stream}`.toLowerCase(), c.id);
    }
    classLookup.set(c.level.toLowerCase(), c.id);
  });

  const resetState = () => {
    setStep('upload');
    setParsedData([]);
    setValidationErrors([]);
    setImportProgress(0);
    setAutoGenerateForEmpty(true);
    setImportResults({ students: 0, parents: 0, classAssignments: 0, autoGenerated: 0, failed: 0 });
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleClose = () => {
    resetState();
    onOpenChange(false);
  };

  const validateData = useCallback((data: ParsedStudent[], autoGen: boolean): ValidationError[] => {
    const errors: ValidationError[] = [];
    const seenAdmissionNumbers = new Set<string>();

    data.forEach((row, index) => {
      const rowNum = index + 2; // +2 because row 1 is header, and we're 0-indexed

      // Admission number validation - skip if auto-generate is enabled and field is empty
      const hasAdmissionNumber = row.admission_number?.trim();
      if (!hasAdmissionNumber && !autoGen) {
        errors.push({ row: rowNum, field: 'admission_number', message: 'Admission number is required (or enable auto-generate)' });
      } else if (hasAdmissionNumber) {
        // Check for duplicates within file
        if (seenAdmissionNumbers.has(row.admission_number.trim())) {
          errors.push({ row: rowNum, field: 'admission_number', message: 'Duplicate admission number in file' });
        }
        seenAdmissionNumbers.add(row.admission_number.trim());

        // Check against existing students
        if (existingAdmissionNumbers.includes(row.admission_number.trim())) {
          errors.push({ row: rowNum, field: 'admission_number', message: 'Admission number already exists' });
        }
      }

      if (!row.first_name?.trim()) {
        errors.push({ row: rowNum, field: 'first_name', message: 'First name is required' });
      }

      if (!row.last_name?.trim()) {
        errors.push({ row: rowNum, field: 'last_name', message: 'Last name is required' });
      }

      // Optional field validation with improved error messages
      if (row.gender && !['male', 'female', 'other'].includes(row.gender.toLowerCase())) {
        errors.push({ row: rowNum, field: 'gender', message: formatValidationError('gender', row.gender, 'students') });
      }

      if (row.date_of_birth && isNaN(Date.parse(row.date_of_birth))) {
        errors.push({ row: rowNum, field: 'date_of_birth', message: formatValidationError('date_of_birth', row.date_of_birth, 'students') });
      }

      if (row.admission_date && isNaN(Date.parse(row.admission_date))) {
        errors.push({ row: rowNum, field: 'admission_date', message: formatValidationError('admission_date', row.admission_date, 'students') });
      }

      // Boarding status validation
      if (row.boarding_status && !['boarder', 'day', 'day scholar'].includes(row.boarding_status.toLowerCase())) {
        errors.push({ row: rowNum, field: 'boarding_status', message: formatValidationError('boarding_status', row.boarding_status, 'students') });
      }

      // Parent relationship validation
      if (row.parent_relationship && !['mother', 'father', 'guardian', 'parent', 'uncle', 'aunt', 'grandparent'].includes(row.parent_relationship.toLowerCase())) {
        errors.push({ row: rowNum, field: 'parent_relationship', message: formatValidationError('parent_relationship', row.parent_relationship, 'students') });
      }
    });

    return errors;
  }, [existingAdmissionNumbers, classLookup]);

  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse<Record<string, string>>(file, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.trim().toLowerCase().replace(/\s+/g, '_'),
      complete: (results) => {
        const data = results.data.map((row) => ({
          admission_number: row.admission_number?.trim() || '',
          first_name: row.first_name?.trim() || '',
          middle_name: row.middle_name?.trim() || undefined,
          last_name: row.last_name?.trim() || '',
          gender: row.gender?.trim().toLowerCase() || undefined,
          date_of_birth: row.date_of_birth?.trim() || undefined,
          nationality: row.nationality?.trim() || undefined,
          admission_date: row.admission_date?.trim() || undefined,
          // Enhanced fields
          class_name: row.class_name?.trim() || undefined,
          stream: row.stream?.trim() || undefined,
          boarding_status: row.boarding_status?.trim().toLowerCase() || undefined,
          parent_phone: row.parent_phone?.trim() || undefined,
          parent_name: row.parent_name?.trim() || undefined,
          parent_email: row.parent_email?.trim() || undefined,
          parent_relationship: row.parent_relationship?.trim().toLowerCase() || undefined,
          // Flag for auto-generation
          _needs_admission_number: !row.admission_number?.trim(),
        }));

        const errors = validateData(data, autoGenerateForEmpty);
        setParsedData(data);
        setValidationErrors(errors);
        setStep('preview');
      },
      error: (error) => {
        console.error('CSV parsing error:', error);
        setValidationErrors([{ row: 0, field: 'file', message: 'Failed to parse CSV file' }]);
      },
    });
  }, [validateData, autoGenerateForEmpty]);

  // Re-validate when auto-generate toggle changes
  const handleAutoGenerateToggle = (checked: boolean) => {
    setAutoGenerateForEmpty(checked);
    if (parsedData.length > 0) {
      const errors = validateData(parsedData, checked);
      setValidationErrors(errors);
    }
  };

  const handleImport = async () => {
    if (validationErrors.length > 0) return;

    setStep('importing');
    
    let studentCount = 0;
    let parentCount = 0;
    let classAssignmentCount = 0;
    let autoGeneratedCount = 0;
    let failedCount = 0;

    const totalOperations = parsedData.length;
    let completedOperations = 0;

    // Process students one by one to handle class and parent linking
    for (const row of parsedData) {
      try {
        // Determine class_id from class_name
        let classId: string | null = null;
        if (row.class_name) {
          const lookupKey = row.stream 
            ? `${row.class_name} ${row.stream}`.toLowerCase()
            : row.class_name.toLowerCase();
          classId = classLookup.get(lookupKey) || classLookup.get(row.class_name.toLowerCase()) || null;
        }

        // Get admission number - generate if empty and auto-generate is enabled
        let admissionNumber = row.admission_number?.trim() || '';
        if (!admissionNumber && autoGenerateForEmpty) {
          // Call the database function to generate admission number
          const { data: generatedNumber, error: genError } = await supabase
            .rpc('generate_admission_number', { _institution_id: institutionId });
          
          if (genError) throw genError;
          admissionNumber = generatedNumber as string;
          autoGeneratedCount++;
        }

        // Create student
        const studentData = {
          institution_id: institutionId,
          admission_number: admissionNumber,
          first_name: row.first_name.trim(),
          middle_name: row.middle_name || null,
          last_name: row.last_name.trim(),
          gender: row.gender || null,
          date_of_birth: row.date_of_birth || null,
          nationality: row.nationality || null,
          admission_date: row.admission_date || new Date().toISOString().split('T')[0],
          status: 'active',
          class_id: classId,
          boarding_status: row.boarding_status === 'boarder' ? 'boarder' : row.boarding_status === 'day' || row.boarding_status === 'day scholar' ? 'day' : null,
        };

        const { data: student, error: studentError } = await supabase
          .from('students')
          .insert(studentData)
          .select()
          .single();

        if (studentError) throw studentError;
        
        studentCount++;
        if (classId) classAssignmentCount++;

        // Handle parent creation and linking
        if (row.parent_phone && row.parent_name && student) {
          // Check if parent already exists by phone
          const { data: existingParent } = await supabase
            .from('parents')
            .select('id')
            .eq('institution_id', institutionId)
            .eq('phone', row.parent_phone)
            .maybeSingle();

          let parentId: string;

          if (existingParent) {
            parentId = existingParent.id;
          } else {
            // Parse parent name (assume "First Last" format)
            const nameParts = row.parent_name.trim().split(/\s+/);
            const firstName = nameParts[0] || '';
            const lastName = nameParts.slice(1).join(' ') || nameParts[0] || '';

            const { data: newParent, error: parentError } = await supabase
              .from('parents')
              .insert({
                institution_id: institutionId,
                phone: row.parent_phone,
                first_name: firstName,
                last_name: lastName,
                email: row.parent_email || null,
                relationship: row.parent_relationship || 'parent',
              })
              .select()
              .single();

            if (parentError) {
              console.error('Parent creation error:', parentError);
            } else {
              parentId = newParent.id;
              parentCount++;
            }
          }

          // Link parent to student
          if (parentId!) {
            await supabase.from('student_parents').insert([{
              institution_id: institutionId,
              student_id: student.id,
              parent_id: parentId,
              relationship: row.parent_relationship || 'parent',
              is_primary: true,
            }]);
          }
        }

      } catch (error) {
        console.error('Import error for row:', row, error);
        failedCount++;
      }

      completedOperations++;
      setImportProgress(Math.round((completedOperations / totalOperations) * 100));
    }

    setImportResults({ 
      students: studentCount, 
      parents: parentCount, 
      classAssignments: classAssignmentCount,
      autoGenerated: autoGeneratedCount,
      failed: failedCount 
    });
    setStep('complete');
  };

  const downloadTemplate = () => {
    const headers = ALL_COLUMNS.join(',');
    const sampleRow = 'STU001,John,William,Doe,male,2010-05-15,Kenyan,2024-01-10,Grade 1,A,day,+254712345678,Jane Doe,jane@email.com,mother';
    const sampleRow2 = 'STU002,Mary,,Jane,female,2011-03-20,Kenyan,2024-01-10,Grade 2,,boarder,+254723456789,James Jane,james@email.com,father';
    const csvContent = `${headers}\n${sampleRow}\n${sampleRow2}`;
    
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'student_import_template.csv';
    a.click();
    URL.revokeObjectURL(url);
  };

  const rowsWithErrors = new Set(validationErrors.map((e) => e.row));
  const validRows = parsedData.filter((_, index) => !rowsWithErrors.has(index + 2));

  // Count rows with class assignments and parent data
  const rowsWithClass = parsedData.filter(r => r.class_name && classLookup.has(r.class_name.toLowerCase())).length;
  const rowsWithParent = parsedData.filter(r => r.parent_phone && r.parent_name).length;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="w-full max-w-2xl sm:max-w-4xl max-h-[85vh] sm:max-h-[90vh] flex flex-col">
        <DialogHeader className="flex-shrink-0">
          <DialogTitle>Enhanced Student Import</DialogTitle>
          <DialogDescription>
            Import students with automatic class assignment and parent linking
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto">
          {step === 'upload' && (
            <div className="space-y-4">
              <div
                className="flex flex-col items-center justify-center rounded-lg border-2 border-dashed border-muted-foreground/25 p-12 hover:border-primary/50 transition-colors cursor-pointer"
                onClick={() => fileInputRef.current?.click()}
              >
                <Upload className="h-12 w-12 text-muted-foreground/50" />
                <p className="mt-4 text-sm font-medium">Click to upload or drag and drop</p>
                <p className="text-xs text-muted-foreground">CSV files only</p>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept=".csv"
                  onChange={handleFileUpload}
                  className="hidden"
                />
              </div>

              <ImportColumnReference 
                importType="students"
                dynamicData={{
                  classes: classes?.map(c => ({ name: c.name, level: c.level, stream: c.stream || undefined })) || [],
                }}
              />

              <Button variant="outline" onClick={downloadTemplate} className="gap-2">
                <Download className="h-4 w-4" />
                Download Enhanced Template
              </Button>
            </div>
          )}

          {step === 'preview' && (
            <div className="space-y-4">
              {/* Auto-generate toggle */}
              {parsedData.some(r => r._needs_admission_number) && (
                <div className="flex items-center justify-between rounded-lg border p-3 bg-primary/5">
                  <div className="flex items-center gap-2">
                    <Sparkles className="h-4 w-4 text-primary" />
                    <div>
                      <Label className="text-sm font-medium">Auto-generate admission numbers</Label>
                      <p className="text-xs text-muted-foreground">
                        {parsedData.filter(r => r._needs_admission_number).length} rows need admission numbers
                      </p>
                    </div>
                  </div>
                  <Switch
                    checked={autoGenerateForEmpty}
                    onCheckedChange={handleAutoGenerateToggle}
                  />
                </div>
              )}

              <div className="flex flex-wrap items-center gap-3">
                <Badge variant="outline" className="gap-1">
                  <Users className="h-3 w-3" />
                  {parsedData.length} students
                </Badge>
                <Badge variant="outline" className="gap-1 bg-blue-50 text-blue-700">
                  {rowsWithClass} with class
                </Badge>
                <Badge variant="outline" className="gap-1 bg-purple-50 text-purple-700">
                  <UserPlus className="h-3 w-3" />
                  {rowsWithParent} with parent
                </Badge>
                {validationErrors.length > 0 ? (
                  <Badge variant="destructive" className="gap-1">
                    <AlertCircle className="h-3 w-3" />
                    {validationErrors.length} errors
                  </Badge>
                ) : (
                  <Badge variant="default" className="gap-1">
                    <CheckCircle2 className="h-3 w-3" />
                    All valid
                  </Badge>
                )}
              </div>

              {validationErrors.length > 0 && (
                <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4">
                  <div className="flex items-center gap-2 text-destructive mb-2">
                    <AlertCircle className="h-4 w-4" />
                    <span className="font-medium">{validationErrors.length} validation errors found</span>
                  </div>
                  <ScrollArea className="h-24">
                    <ul className="list-disc pl-4 text-sm space-y-1">
                      {validationErrors.slice(0, 10).map((error, i) => (
                        <li key={i}>
                          Row {error.row}: {error.field} - {error.message}
                        </li>
                      ))}
                      {validationErrors.length > 10 && (
                        <li className="text-muted-foreground">...and {validationErrors.length - 10} more errors</li>
                      )}
                    </ul>
                  </ScrollArea>
                </div>
              )}

              <ScrollArea className="h-64 rounded-md border">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-12">#</TableHead>
                      <TableHead>Adm. No.</TableHead>
                      <TableHead>Name</TableHead>
                      <TableHead>Class</TableHead>
                      <TableHead>Parent</TableHead>
                      <TableHead>Status</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {parsedData.slice(0, 50).map((row, index) => {
                      const hasError = rowsWithErrors.has(index + 2);
                      const hasValidClass = row.class_name && classLookup.has(row.class_name.toLowerCase());
                      return (
                        <TableRow key={index} className={hasError ? 'bg-destructive/10' : ''}>
                          <TableCell className="font-mono text-xs">{index + 1}</TableCell>
                          <TableCell>{row.admission_number}</TableCell>
                          <TableCell>{row.first_name} {row.last_name}</TableCell>
                          <TableCell>
                            {row.class_name ? (
                              hasValidClass ? (
                                <Badge variant="outline" className="bg-blue-50 text-blue-700">
                                  {row.class_name} {row.stream || ''}
                                </Badge>
                              ) : (
                                <Badge variant="outline" className="bg-yellow-50 text-yellow-700">
                                  {row.class_name} (not found)
                                </Badge>
                              )
                            ) : (
                              <span className="text-muted-foreground">-</span>
                            )}
                          </TableCell>
                          <TableCell>
                            {row.parent_phone ? (
                              <Badge variant="outline" className="bg-purple-50 text-purple-700">
                                {row.parent_name || row.parent_phone}
                              </Badge>
                            ) : (
                              <span className="text-muted-foreground">-</span>
                            )}
                          </TableCell>
                          <TableCell>
                            {hasError ? (
                              <Badge variant="destructive" className="gap-1">
                                <X className="h-3 w-3" />
                                Error
                              </Badge>
                            ) : (
                              <Badge variant="outline" className="gap-1">
                                <CheckCircle2 className="h-3 w-3" />
                                Valid
                              </Badge>
                            )}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
                {parsedData.length > 50 && (
                  <p className="p-2 text-center text-xs text-muted-foreground">
                    Showing first 50 of {parsedData.length} rows
                  </p>
                )}
              </ScrollArea>
            </div>
          )}

          {step === 'importing' && (
            <div className="flex flex-col items-center justify-center py-12">
              <p className="mb-4 text-lg font-medium">Importing students...</p>
              <Progress value={importProgress} className="w-64" />
              <p className="mt-2 text-sm text-muted-foreground">{importProgress}% complete</p>
              <p className="mt-1 text-xs text-muted-foreground">Creating students, linking parents and classes...</p>
            </div>
          )}

          {step === 'complete' && (
            <div className="flex flex-col items-center justify-center py-12">
              <CheckCircle2 className="h-16 w-16 text-green-500" />
              <p className="mt-4 text-lg font-medium">Import Complete</p>
              <div className="mt-4 grid grid-cols-2 gap-4 text-center">
                <div className="p-3 bg-muted rounded-lg">
                  <p className="text-2xl font-bold text-primary">{importResults.students}</p>
                  <p className="text-sm text-muted-foreground">Students Created</p>
                </div>
                <div className="p-3 bg-muted rounded-lg">
                  <p className="text-2xl font-bold text-purple-600">{importResults.parents}</p>
                  <p className="text-sm text-muted-foreground">Parents Created</p>
                </div>
                <div className="p-3 bg-muted rounded-lg">
                  <p className="text-2xl font-bold text-blue-600">{importResults.classAssignments}</p>
                  <p className="text-sm text-muted-foreground">Class Assignments</p>
                </div>
                {importResults.autoGenerated > 0 && (
                  <div className="p-3 bg-muted rounded-lg">
                    <p className="text-2xl font-bold text-amber-600">{importResults.autoGenerated}</p>
                    <p className="text-sm text-muted-foreground">Auto-Generated IDs</p>
                  </div>
                )}
                {importResults.failed > 0 && (
                  <div className="p-3 bg-destructive/10 rounded-lg">
                    <p className="text-2xl font-bold text-destructive">{importResults.failed}</p>
                    <p className="text-sm text-muted-foreground">Failed</p>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        <DialogFooter className="flex-shrink-0">
          {step === 'upload' && (
            <Button variant="outline" onClick={handleClose}>
              Cancel
            </Button>
          )}
          {step === 'preview' && (
            <>
              <Button variant="outline" onClick={resetState}>
                Upload Different File
              </Button>
              <Button
                onClick={handleImport}
                disabled={validationErrors.length > 0 || parsedData.length === 0}
              >
                Import {validRows.length} Students
              </Button>
            </>
          )}
          {step === 'complete' && (
            <Button onClick={handleClose}>Done</Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
